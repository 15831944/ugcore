
/**	\page pageSTRegistry ug-Registry Tutorial

In order to make functionality (such as c++ classes, methods and functions) 
available in the Lua-Script or the VRL, this functionality must be registered
by the c++ programmer. By this registration, the programmer indicates, that the
functionality is exported. Once exported the functionality is accessible in 
Script and VRL simultaneously.

This page gives an introduction to the registration process.

<hr>
\section secSTHowToRegister	How to register Functionality
<hr>

Registering is done in the *.cpp files in the folder "ugbase/ug_bridge/bridges".
Here are found several so called "bridges" that map (bridge) the functionality of 
different parts of the software project to the script (or VRL). 

To understand the usage of the ug::Registry, lets start with the simple and
exemplary file "test_bridges.cpp". Here, you find several simple test classes
and functions, written in normal c++. This functionality is now exported. 

The function, where the registration takes place is "RegisterTestInterface".

\code
bool RegisterTestInterface(Registry& reg, const char* parentGroup)
{
//	usually the parentGroup is "ug4"

//	get group string
	std::stringstream groupString; groupString << parentGroup << "/Test";
	std::string grp = groupString.str();

//	now groupString is simply "ug4/Test"

//  ...
}
\endcode

This function gets passed the Registry to which all functionality is added. In
addition a "Group" string is added, that can be used to group functionality together.
Usually all separated parts (e.g. "Grid", "Algebra", ...) are grouped, but this
is not essential for the registration. (Therefore, lets not stress this point here)

<hr>
\section secSTHowToRegisterFunctions 	How to register Global Functions
<hr>

Now, we come to the point to register a global c++-Function. We start with 
a very simple example, the famous "Hello World". You will find in the file
a global Function "PrintHelloWorldToScreen"

\code
// prints "Hello World"
void PrintHelloWorldToScreen()
{
	UG_LOG("Hello World !\n");
}
\endcode

In order to export this global function, you must use the syntax

\code
reg.add_function( "NameAppearingInScript", Pointer to Function, ... )
\endcode

For the "Hello World" function this reads:

\code 
//	registering hello world
	reg.add_function("PrintHelloWorld", &PrintHelloWorldToScreen);
\endcode

Now, you can call this function in the Script. So, start the ug shell in your
terminal:

\verbatim
user$ ./ugshell 
****************
* ugshell - v4.0.1
* arguments:
*   -outproc id:	Sets the output-proc to id. Default is 0.
*   -ex scriptname:	Executes the specified script.
*   -noquit:       	Does run the interactive shell after specified script.
*   -noterm:			Terminal logging will be disabled.
*   -logtofile filename:	Output will be written to the specified file.
* Additional parameters are passed to the script through ugargc and ugargv.
****************
ug:> 
\endverbatim

Now, just type the function:

\verbatim
ug:> PrintHelloWorld()
Hello World !
ug:> 
\endverbatim

<hr>
\section secSTHowToRegisterClasses 	How to register Classes and Methods
<hr>

C++-Classes and their methods are registered similarly. Lets focus on the
example class "Test":

\code
class Test
{
	public:
		int add(int a, int b)
		{
			return a+b;
		}

		int print_name()
		{
			UG_LOG("Name is Test\n");
			return 1;
		}
		
		int print()			{UG_LOG("Test::print()\n"); return 0;}
		int print() const	{UG_LOG("Test::print() const\n"); return 1;}
};
\endcode 

This class is registered by

\code
//	register class "Test"
	reg.add_class_<Test>("Test", grp.c_str())
		.add_constructor()
		.add_method("add", &Test::add, "c", "a,b")
		.add_method("print_name", &Test::print_name);
\endcode

The following is done here:
<ul>
<li> In add_class_< Class > the exported class is specified
<li> By "Test" is specified the name of the class used in the script
<li> By ".add_constructor()" is specified, that the constructor is available in
	the script. 
<li> By ".add_method("MethodNameInSkript", Pointer to method) a method is 
	exported.
</ul>

Now, you can create an object of this class from script using the "()"-operator:

\verbatim
ug:> myClass = Test()
\endverbatim

Calling a method of the class is done by using the ":"-operator

\verbatim
ug:> myClass:print_name()
Name is Test
\endverbatim

<hr>
\section secSTHowToRegisterBaseClasses 	How to register Base Classes
<hr>

Class hierarchies can also be exported to the Script. Please note, that currently
only <b>one base class is supported</b> (i.e. multiply derivation is not possible
in the registry). In order to register a base class, use the usual C++-syntax:

\code
class Base
{
	public:
		virtual ~Base()	{}
		virtual void print() = 0;
};

class Derived : public Base
{
	public:
		virtual ~Derived()	{}
		virtual void print()
		{
			UG_LOG("Derived::print() called\n");
		}
};
\endcode

Now, in registration, add the base class <b>without</b> constructor:

\code
//	registering base class (without constructor)
	reg.add_class_<Base>("Base", grp.c_str())
		.add_method("print", &Base::print);
\endcode

When registering the Derived class, add also the Base class as a second template
argument.

\code
//	registering derived class
	reg.add_class_<Derived, Base>("Derived", grp.c_str())
		.add_constructor();
\endcode

<hr>
\section secSTHowToRegisterOverloadedMethods 	How to register Overloaded Methods
<hr>

When a method (or function) is overloaded, the compiler can not find the method
you want to register by only passing the method pointer. You have to explicitly
specify the method signature to choose between the possibilities:

\code
class Test
{
	public:
	// 	... something ...		
	
	//	overloaded functions
		int print()			{UG_LOG("Test::print()\n"); return 0;}
		int print() const	{UG_LOG("Test::print() const\n"); return 1;}
};
\endcode

\code
//	register class "Test"
	reg.add_class_<Test>("Test", grp.c_str())
		.add_method("print", (int(Test::*)()) &Test::print)
		.add_method("print", (int(Test::*)() const) &Test::print);
\endcode

*/
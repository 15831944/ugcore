/**	\page pageUG4Registry ug-Registry Tutorial

In order to make functionality (such as c++ classes, methods and functions) 
available in the Lua-Script or the VRL, this functionality must be registered
by the c++ programmer. By this registration, the programmer indicates, that the
functionality is exported. Once exported the functionality is accessible in 
Script and VRL simultaneously.

This page gives an introduction to the registration process.

<hr>
\section secSTHowToRegister	How to register Functionality
<hr>

Registering is done in the *.cpp files in the folder "ugbase/ug_bridge/bridges".
Here are found several so called "bridges" that map (bridge) the functionality of 
different parts of the software project to the script (or VRL). 

To understand the usage of the ug::Registry, lets start with the simple and
exemplary file "test_bridges.cpp". Here, you find several simple test classes
and functions, written in normal c++. This functionality is now exported. 

The function, where the registration takes place is "RegisterTestInterface".

\code
bool RegisterTestInterface(Registry& reg, const char* parentGroup)
{
//	usually the parentGroup is "ug4"

//	get group string
	std::stringstream groupString; groupString << parentGroup << "/Test";
	std::string grp = groupString.str();

//	now groupString is simply "ug4/Test"

//  ...
}
\endcode

This function gets passed the Registry to which all functionality is added. In
addition a "Group" string is added, that can be used to group functionality together.
Usually all separated parts (e.g. "Grid", "Algebra", ...) are grouped, but this
is not essential for the registration. (Therefore, lets not stress this point here)

<hr>
\section secSTHowToRegisterFunctions 	How to register Global Functions
<hr>

Now, we come to the point to register a global c++-Function. We start with 
a very simple example, the famous "Hello World". You will find in the file
a global Function "PrintHelloWorldToScreen"

\code
// prints "Hello World"
void PrintHelloWorldToScreen()
{
	UG_LOG("Hello World !\n");
}
\endcode

In order to export this global function, you must use the syntax

\code
reg.add_function( "NameAppearingInScript", Pointer to Function, ... )
\endcode

For the "Hello World" function this reads:

\code 
//	registering hello world
	reg.add_function("PrintHelloWorld", &PrintHelloWorldToScreen);
\endcode

Now, you can call this function in the Script. So, start the ug shell in your
terminal:

\verbatim
user$ ./ugshell 
********************************************************************************
* ugshell - v4.0.1                                                             *
*                                                                              *
* arguments:                                                                   *
*   -outproc id:         Sets the output-proc to id. Default is 0.             *
*   -ex scriptname:      Executes the specified script.                        *
*   -noquit:             Runs the interactive shell after specified script.    *
*   -noterm:             Terminal logging will be disabled.                    *
*   -logtofile filename: Output will be written to the specified file.         *
* Additional parameters are passed to the script through ugargc and ugargv.    *
********************************************************************************
ug:> 
\endverbatim

Now, just type the function:

\verbatim
ug:> PrintHelloWorld()
Hello World !
ug:> 
\endverbatim/

<hr>
\section secSTHowToRegisterClasses 	How to register Classes and Methods
<hr>

C++-Classes and their methods are registered similarly. Lets focus on the
example class "Test":

\code
class Test
{
	public:
		int add(int a, int b)
		{
			return a+b;
		}

		int print_name()
		{
			UG_LOG("Name is Test\n");
			return 1;
		}
		
		int print()			{UG_LOG("Test::print()\n"); return 0;}
		int print() const	{UG_LOG("Test::print() const\n"); return 1;}
};
\endcode 

This class is registered by

\code
//	register class "Test"
	reg.add_class_<Test>("Test", grp)
		.add_constructor()
		.add_method("add", &Test::add, "c", "a#b")
		.add_method("print_name", &Test::print_name);
\endcode

The following is done here:
<ul>
<li> In add_class_< Class > the exported class is specified
<li> By "Test" is specified the name of the class used in the script
<li> By ".add_constructor()" is specified, that the constructor is available in
	the script. 
<li> By ".add_method("MethodNameInSkript", Pointer to method) a method is 
	exported.
</ul>

Now, you can create an object of this class from script using the "()"-operator:

\verbatim
ug:> myClass = Test()
\endverbatim

Calling a method of the class is done by using the ":"-operator

\verbatim
ug:> myClass:print_name()
Name is Test
\endverbatim

<hr>
\section secSTHowToSpecifyParameterInformation 	How to specify parameter information
<hr>

As shown in the last example, the <code>.add_method()</code> method allows to specify
additional parameter related information. The first string after the method pointer 
specifies properties of the return value: <code>"c"</code>.The second string specifies
properties of the parameters of the registered method:
<code>"a#b"</code>.

These properties allow VRL and the Script to provide additional information for the
registered methods. Apart from the \em name, in this case <code>c</code>,
VRL uses a so called \em style identifier to choose between
several possible type representations. Additional \em options allow to specify
range conditions, default values etc.

<hr>
\subsection secParamStrings Syntax
<hr>

Parameter properties can be specified as follows:

\code
name | style | options
\endcode

The short form <code>"name"</code> is also valid if no additional option shall be
specified.

An example for return value properties: <code>"c|default|min=1;max=10"</code>.

For the parameter string an additional separator is used to split the
individual parameter properties. Parameters can be separated as follows
(seperating two parameters):

\code
name1 | style1 | options1 # name2 | style2 | options2
\endcode

<hr>
\subsection secParamStringsAvaliableOptions Available styles and options
<hr>

\subsubsection secParamStringsName Name

For the name it is safe to specify ASCII strings.
Roughly speaking, it is safe to specify strings consisting of letters from
the latin alphabet, numbers and characters from the following list:
<code>^!"ยง$%&/()=?*,.-;:_<>\@</code> (list may be not complete).

VRL supports simple HTML syntax (most tags from HTML 3.x are supported).
Thus, it is possible to request bold or underlined names. Using colors and other
enhanced stylings should not be used as this will most likely conflict with the VRL
interface styles because in this case VRL cannot automatically change the text color
accordingly.

\note Special characters and control characters, such as <code>\\n</code> are not
supported. The characters <code>|</code> and <code>#</code> must not be used either.

<hr>
\subsubsection secParamStringsStyle Style

VRL uses a so called \em style \em identifier to choose between type representations.
The most relevant type representations for UG are listed below 
(more details can be found in the VRL API documentation):

<hr>
<b>Type representations for the \em number type:</b>
<hr>


style identifier: <code>default</code>

possible options: min, max, value

example string: <code>"Double|default|min=1D;max=100D;value=50D"</code>

\image html img/vrl/double-default-01.png

<hr>
<b>Type representations for the \em integer type:</b>
<hr>


style identifier: <code>default</code>

possible options: min, max, value

example string: <code>"Integer|default|min=1;max=100;value=50"</code>

\image html img/vrl/integer-default-01.png
<hr>

style identifier: <code>slider</code>

possible options: min, max

example string: <code>"Integer|slider|min=1;max=255"</code>

\image html img/vrl/integer-slider-01.png
<hr>

style identifier: <code>selection</code>

possible options: min, max

example string: <code>"Integer|selection|value=[1,2,3]"</code>

\image html img/vrl/selection-integer-01.png

<hr>
<b>Type representations for the \em string type:</b>
<hr>

style identifier: <code>default</code>

possible options: - none -

example string: <code>"String|default"</code>

\image html img/vrl/string-default-01.png
<hr>

style identifier: <code>load-dialog</code> or <code>save-dialog</code> 

possible options: endings, description

example string: <code>"File Name|load-dialog|
                endings=[\"png\\",\"jpg\\"];description=\"Image-Files\\""</code>

\image html img/vrl/load-dialog-01.png
<br>
\image html img/vrl/load-dialog-02.png
<hr>

style identifier: <code>selection</code>

possible options: value

example string: <code>"String|selection|value=[\"string1\\",\"string2\\"]"</code>

\image html img/vrl/selection-string-01.png


<hr>
\section secSTHowToRegisterBaseClasses 	How to register Base Classes
<hr>

Class hierarchies can also be exported to the Script. Please note, that currently
only <b>one base class is supported</b> (i.e. multiply derivation is not possible
in the registry). In order to register a base class, use the usual C++-syntax:

\code
class Base
{
	public:
		virtual ~Base()	{}
		virtual void print() = 0;
};

class Derived : public Base
{
	public:
		virtual ~Derived()	{}
		virtual void print()
		{
			UG_LOG("Derived::print() called\n");
		}
};
\endcode

Now, in registration, add the base class <b>without</b> constructor:

\code
//	registering base class (without constructor)
	reg.add_class_<Base>("Base", grp)
		.add_method("print", &Base::print);
\endcode

When registering the Derived class, add also the Base class as a second template
argument.

\code
//	registering derived class
	reg.add_class_<Derived, Base>("Derived", grp)
		.add_constructor();
\endcode

<hr>
\section secSTHowToRegisterOverloadedMethods 	How to register Overloaded Methods
<hr>

When a method (or function) is overloaded, the compiler can not find the method
you want to register by only passing the method pointer. You have to explicitly
specify the method signature to choose between the possibilities:

\code
class Test
{
	public:
	// 	... something ...		
	
	//	overloaded functions
		int print()			{UG_LOG("Test::print()\n"); return 0;}
		int print() const	{UG_LOG("Test::print() const\n"); return 1;}
};
\endcode

\code
//	register class "Test"
	reg.add_class_<Test>("Test", grp)
		.add_method("print", (int(Test::*)()) &Test::print)
		.add_method("print", (int(Test::*)() const) &Test::print);
\endcode

<hr>
\section secSTHowToRegisterOverloadedConstructors 	How to register Overloaded Constructors
<hr>

Constructors with parameters and several (overloaded) Constructors are also 
possible. Since it is impossible to take the function point of a constructor the 
special method "add_constructor<SignatureFunction>(...)" must be used. 

\code
class Test
{
	public:
		Test() { UG_LOG("Test::Test() constructor used.\n")}
		Test(const char* msg)
		{
			UG_LOG("Test::Test(const char*) constructor used.\n")
			UG_LOG("Message is: '"<<msg<<"'.\n");
		}
};
\endcode

\code
//	register class "Test"
	reg.add_class_<Test>("Test", grp)
		.add_constructor()
		.add_constructor<void (*)(const char*)>("Message");
\endcode

The template argument of the add_constructor method must be a global function pointer
with void return value. The signature of the function pointer type is used to 
get the arguments of the constructor. In total these informations can be passed 
when registering a constructor:

\code
	template <typename TFunc>
	ExportedClass<TClass>& add_constructor(std::string paramInfos = "",
	                                       std::string tooltip = "", std::string help = "",
	                                       std::string options = "")
\endcode
 
<ul>
<li> paramInfos: a list of parameter names (and options) separated by '#' (see above)
<li> tooltip: Some information about the usage of the constructor
<li> help: Help informations
<li> options: style option of the constructor itself (for visualisation)
</ul>

*/

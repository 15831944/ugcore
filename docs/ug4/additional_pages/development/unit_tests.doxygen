//	created by Andreas Vogel
//	andreas.vogel@gcsc.uni-frankfurt.de
//	y11 m11 d10

/** \page pageUnitTests Unit Tests

For the unit testing of \ug4 the <em>Boost Testing Library</em> 
is used.
The test are run by the Continuous Integration Service "Jenkins" (currently on 
<tt>cave1.gcsc.uni-frankfurt.de</tt>) daily.
If a test fails reporting email will be sent to the causing developers.

<em>Unit Tests</em> can be carried out in two ways:

- \ref secUnitTestsCode
- \ref secUnitTestsScripts

For any questions, contact martin.scherer@gcsc.uni-frankfurt.de or
 andreas.vogel@gcsc.uni-frankfurt.de.


<hr>
\section secUnitTestsCode Testing Code

In order to test the C++-Code directly one can write a piece of code, that is 
tested automatically.
All unit test code should be placed in <tt>unit_tests/src/*.cpp</tt>.

If you want to test your own code, add a <tt>*.cpp</tt> file in that section 
and add your file in the <tt>CMakeList.txt</tt> file.
 
Then start your own test suite as shown by this self-explanatory example:
\code
// register test suite
BOOST_AUTO_TEST_SUITE(myNameSuiteNumProc1);

// add a test
BOOST_AUTO_TEST_CASE(myTest)
{
  int a = 1, b = 2;

  // write a message
  BOOST_MESSAGE("Starting some test")
	
  // check 
  BOOST_CHECK_MESSAGE(a+b == 3, "1+2 must be 3");
  BOOST_REQUIRE_MESSAGE(a+b == 3, "1+2 must be 3");
}

// end of test suite
BOOST_AUTO_TEST_SUITE_END();
\endcode

In Detail:

A test suite is used to group several test together and all test suits will be
detected and tested.
<tt>BOOST_AUTO_TEST_SUITE</tt> starts a new test suite, that is ended by
<tt>BOOST_AUTO_TEST_SUITE_END</tt>.
The name of suite must be a valid C++-Name.

\note The Ending of a Suite must be (by our convention) <tt>*NumProcsXX</tt>, 
where <tt>XX</tt> is the number of processes the suite should be run with 
(i.e. MPI-Processes).

<tt>BOOST_AUTO_TEST_CASE</tt> defines a test.
There can be as many test cases in a suite as you like.
Using the macros <tt>BOOST_REQUIRE_MESSAGE</tt>, <tt>BOOST_CHECK_MESSAGE</tt> 
you can now assert several conditions in your code.


<hr>
\section secUnitTestsScripts Testing Scripts

In order to test Lua-Scripts you just have to add the script, that you want to 
test in the file <tt>unit_tests/src/testScripts.cpp</tt>.
See this example:
\code
////////////////////////////////////////////////////////////////////////////////
// Test Cases for Num Proc = 1 (quasi-serial case)
////////////////////////////////////////////////////////////////////////////////
BOOST_AUTO_TEST_SUITE(testLUAScriptsNumProc1);

// add more script test cases below...
BOOST_AUTO_TEST_CASE(sampleScript) 	{loadScriptWrapper("../unit_tests/scripts/sample_test.lua");}
BOOST_AUTO_TEST_CASE(laplace) 		{loadScriptWrapper("../apps/conv_diff/laplace_test.lua");}

BOOST_AUTO_TEST_SUITE_END();

////////////////////////////////////////////////////////////////////////////////
// Test Cases for Num Proc = 3 (parallel case)
////////////////////////////////////////////////////////////////////////////////
BOOST_AUTO_TEST_SUITE(testLUAScriptsNumProc3);

// add more script test cases below...
BOOST_AUTO_TEST_CASE(laplace) 		{loadScriptWrapper("../apps/conv_diff/laplace_test.lua");}

BOOST_AUTO_TEST_SUITE_END();
\endcode

As you see, there are currently two test suits for scripts:
one on a single process and a second one on a 3-MPI-process run.
(If needed, other suits may be added.

\attention This will require a change in the setting of Jenkins!
The scripts, that you add for testing must be specified relative to 
<tt>trunk/scripts/</tt>.

Now, two things are tested:
<ol>
  <li>In any case the successful run of the script (i.e. no <tt>LuaError</tt> 
    reported)
  </li>
  <li>In your script you can add additional requirements and tests as shown in 
    the example below.
  </li>
</ol>

In your script use the functions <tt>test.require(cond, "message")</tt> and 
<tt>test.check(cond,"message")</tt> to ensure conditions during the run of 
the script.
Please note, that this functions are available when <tt>ug_util.lua</tt> is 
included in your script and that &mdash; if no Boost is available &mdash; the 
test functions are replaced by dummy methods (see 
<tt>scripts/util/test_utils.lua</tt>).
An example:
\code
-- Create, Load, Refine and Distribute Domain
neededSubsets = {"Inner", "Boundary"}
dom = util.CreateAndDistributeDomain(gridName, numRefs, numPreRefs, neededSubsets)
test.require(dom ~= nil, "Domain loaded.")

-- create Approximation Space
approxSpace = ApproximationSpace(dom)
approxSpace:add_fct("c", "Lagrange", 1)
approxSpace:print_statistic()

-- lets order indices using Cuthill-McKee
OrderCuthillMcKee(approxSpace, true);
\endcode

*/


\section secUnitTestsRun Building and running the Testsuite

You are able to use the testsuite locally. To do so you first need build it
\code
mkdir build_test
cd build_test; cmake .. ; make

The testsuite binary will be in the same location as ugshell ($UG4_ROOT/bin).

To run all tests and enable logging to console invoke it with:
test_suite --console

For more parameters please have a look at the boost 
<a href="live.boost.org/doc/libs/1_48_0/libs/test/doc/html/utf/user-guide/runtime-config/reference.html">documentation</a>
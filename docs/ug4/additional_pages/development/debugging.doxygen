//	created by Martin Rupp
//	martin.rupp@gcsc.uni-frankfurt.de
//	y12 m05 d25

/** \page pageDebuggingCPP Debugging UG4's C/C++ Code

- \ref secDebuggingOutput
- \ref secDebuggingUG4CPP
- \ref secDebuggingCPPTroubleshooting
- \ref secDebuggingLUA


<hr>

\section secDebuggingOutput "printf" debugging UG4

We incorporated a logging mechanism into UG4 to faciliate printing messages 
for test purposes. To enable it, you need to make ug with
\verbatim
cmake -DDEBUG_LOGS=ON ..
\endverbatim
(otherwise all UG_DLOG/IF_DEBUGs will be ignored).

It works like this: In your LUA-Script, you add the line
\code
GetLogAssistant():set_debug_level("MAIN", 2)
\endcode

Now the debug level for the \emph DebugID MAIN is set to 2. Now in the C++ code,
you can do logging with UG_LOG, using some ostream functionality like in cout:
\code
UG_LOG("Hello World " << myInteger << "\n");
\endcode
If you want a message to be printed only if the DebugID MAIN is 2, you do
\code
UG_DLOG(MAIN, 2, "my debug message");
\endcode
There's also a way to control if a block is exectuted or not:
\code
IF_DEBUG(MAIN, 3)
{
    // do sth.
}
\endcode
By default, UG4 has the following DebugIDs:
\code
MAIN, APP, LIB_GRID, LIB_GRID_REFINER, LIB_DISC, LIB_DISC_ASSEMBLE, LIB_DISC_D3F,
LIB_DISC_MULTIGRID, LIB_DISC_NEWTON, LIB_DISC_LINKER, LIB_DISC_TRANSER, LIB_DISC_DISCRETE_FUNCTION,
LIB_DISC_OUTPUT, LIB_DISC_OPERATOR_INVERSE, LIB_ALG_LINEAR_OPERATOR, LIB_ALG_LINEAR_SOLVER,
LIB_ALG_VECTOR, LIB_ALG_MATRIX, LIB_ALG_AMG, LIB_PCL
\endcode
For a complete list, use
\code
print(GetLogAssistant():get_debug_IDs())
\endcode
in your script. You can also add custom debug IDs in the following way: You need to create one
global object of the class DebugID (in a cpp-file):
\code
#include "common/log.h"
DebugID DID_MYAPP("MYAPP");
\endcode
Now you can use it in any C++ file this way
\code
#include "common/log.h"
extern DebugID DID_MYAPP;
void myFunction()
{
    UG_DLOG(DID_MYAPP, 1, "my msg");
}
\endcode
and set the debug level in lua
\code
GetLogAssistant():set_debug_level("MYAPP", 1)
\endcode
Note the difference between the DebugID object DID_MYAPP and its associated string "MYAPP" - you can use for both the same, 
of course.
\sa ug::LogAssistant, UG_LOG, UG_DLOG

\section secDebuggingUG4CPP Debugging UG4 with gdb
To debug ug4, you have to make
\verbatim
cmake -DDEBUG=ON ..
\endverbatim
Note \ref secCMake_GCC412 .

Then you do 
\verbatim
gdb ugshell
b myfile.cpp:33
run -ex myscript.lua -myParameter1 3.4 -myOption2
\endverbatim

Another possibility is use <tt>--args</tt>
\verbatim
gdb --args ugshell -ex myscript.lua -myParameter1 3.4 -myOption2
b myfile.cpp:33
run
\endverbatim
For simple parallel debugging, see \ref bashToolsXprun .

\section secDebuggingCPPTroubleshooting Debug Troubleshooting
Sometimes you cannot set breakpoints because the source is in a shared library. This is true for all plugins. 
Also ug4 is loaded dynamically from ugshell. There are two solutions for this:
<ol>
<li> compile ug4 static: <tt>cmake -DSTATIC=ON ..</tt>
<li> adding the breakpoints "pending". you can use <tt>set breakpoint pending on</tt> to avoid the y/n. Note that now gdb won't 
tell you if your filename was wrong.
<li> we've added a function SharedLibrariesLoaded . You can set a breakpoint there with <tt>b SharedLibrariesLoaded</tt>. After that,
you'll be able to break in your plugin/ug4.
</ol>

Best way is to create a <tt>.gdbinit</tt> file in your ug4/bin directory like this:
\verbatim
b SharedLibrariesLoaded
run

echo shared libraries now loaded.\n
# add your breakpoints after this line
# cont
\endverbatim

Then you can start your code with
\verbatim
gdb --args ugshell -ex myscript.lua -myParameter1 3.4 -myOption2
\endverbatim

and it will break right after all shared libraries have been loaded. Now you can add your breakpoints.
\note You will need to <tt>cont</tt> after that, NOT <tt>run</tt>.

You can also add your breakpoints in the .gdbinit file and a <tt>cont</tt> at the end. That way you'll have to type less.

\section secDebuggingLUA Debugging LUA and C++

You can debug your LUA code with the tools here: \ref secDebugging.

\warning Keep in mind that the LUA/ugshell debugger is a completely different thing as the GDB debugger!

You can access the LUA debugger within GDB by writing in the gdb shell
\code
(gdb) call ug::script::breakpoint()
\endcode

This gives you the possibility to check LUA variables and the LUA execution position when your C++ code crashed.
\note You have to enter <tt>cont</tt> to get back to gdb, \em not quit.

If you only need the current LUA execution position, use
\code
(gdb) call ug::bridge::ScriptStacktrace()
\endcode


*/

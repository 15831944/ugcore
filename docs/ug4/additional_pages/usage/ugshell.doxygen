//	created by Martin Rupp
//	martin.rupp@gcsc.uni-frankfurt.de
//	y11 m04 d13

/** \page pageUG4Shell ugshell

- \ref secCommandLineOption
- \ref secInteractiveShell
- \ref secAutoCompletion
- \ref secRuntimeInformation
- \ref secDebugging
- \ref secBashCompletion

For any questions, contact martin.rupp@gcsc.uni-frankfurt.de.


<hr>
\section secCommandLineOption Command-Line Options

\em ugshell has the following build-in command-line options:
- <tt>-outproc id</tt> &mdash; Sets the output-proc to id. Default is 0.
- <tt>-ex scriptname</tt> &mdash; Executes the specified script.
- <tt>-noquit</tt> &mdash; Does run the interactive shell after specified 
  script.
- <tt>-noterm</tt> &mdash; Terminal logging will be disabled.
- <tt>-logtofile filename</tt> & mdash; Output will be written to the specified 
  file.

You can also use the command line to pass arguments to your scripts:
\verbatim
./ugshell -ex tutorials/tut02_loading_a_domain.lua -grid unit_square/unit_square_quads_2x2.ugx  
\endverbatim

You can access command line parameters by using the lua function from 
<a href="ug__util_8lua.html">util.lua</a>:
\code
function util.GetParam(name, return_if_unavailable)
\endcode
For that, you have to include the <tt>ug_util.lua</tt> file using 
<tt>ug_load_script("ug_util.lua")</tt>.


ug_load_script will search for files in the following directories (in that order)
- relative to current script
- as absolute filename
- in the scripts path
- in the apps path
- in the ug4 path.
\note ug_load_script will load files parallel, so you have to be sure that all processes are calling ug_load_script. if you want to load a different file or files only on some cores, you can use ug_load_script_single.

Example:
\code
ug_load_script("ug_util.lua")
gridName = util.GetParam("-grid", "unit_square/unit_square_quads_8x8.ugx")
\endcode
You can find out more about provided scripts in \ref pageLuaScript.

If there is no commandline argument <tt>"-grid"</tt>, then the second argument 
is returned by <tt>util.GetParam</tt>.
Otherwise, the argument after <tt>"-grid"</tt> in the commandline is returned.
Notice that omitted parameters to Lua-functions are treated as <tt>nil</tt>, so 
<tt>util.GetParam("-grid")</tt> is the same as 
<tt>util.GetParam("-grid", nil)</tt>.
If you want your argument to be casted to a number, use 
<tt>util.GetParamNumber</tt>:
\code
function util.GetParamNumber(name, return_if_unavailable)
\endcode
If the argument is not a number, the second argument is returned. 
To check if an option is in the command line, use <tt>util.HasParamOption</tt>:
\code
function util.HasParamOption(name)
\endcode

Examples:
\code
dim = util.GetParamNumber("-dim", 2)
useAggressiveCoarsening = util.HasParamOption("-AC")
\endcode


<hr>
\section secInteractiveShell Interactive Shell

When starting \em ugshell without arguments, you get the following output:
\verbatim
ug:> 
\endverbatim
and a blinking cursor:
This is called the <em>interactive shell</em>.
Interactive shell is disabled when you use \c -ex without \c -noquit and if 
\ug4 is running in parallel.

In the interactive shell you can start the Lue script 
<tt>&lt;scriptname&gt;</tt> (as usual) by executing <tt>ug_load_script()</tt>:
\verbatim
ug:> ug_load_script(<scriptname>)
\endverbatim
where <tt>&lt;scriptname&gt;</tt> is currently searched
<ol>
  <li>relative to the currently loaded script</li>
  <li>absolute,</li>
  <li>relative to <tt>PathProvider::get_path(SCRIPT_PATH)</tt> (i.e 
    <tt>\<ugshelldir\>/../scripts</tt>).
  </li>
</ol>

(Using <tt>ug_load_script()</tt> is the preferred method of loading scripts; 
alternatively a script can be loaded using the (standard Lua) function 
<tt>dofile()</tt>.)

You can abort the execution of \ug4 out of Lua scripts by using 
<tt>exit()</tt>.
If you want to stop the execution of a script at a specific place, but you want 
to use the interactive shell thereafter, insert at that place a call like 
<tt>error("break")</tt> (or whatever message sounds reasonable to you) and 
start the run with the <tt>-noquit</tt>. option

Please note that the interactive shell currently is not available in a parallel 
environment.


<hr>
\section secAutoCompletion Auto Completion

\em ugshell has some auto-completion features implemented.
When you enter a part of something and hit \em tab \em ugshell tries to 
auto-complete your input.
If there is not a unique completion, and you hit \em tab again, you get a list 
of possible completions.

<ul>
  <li>Path Completion:<br>
    <tt>"../scr</tt> -> <tt>"../scripts/</tt><br>
    (only tried if the word left from the cursor starts with a ")
  </li>
  <li>Member Function Completion:<br>
    <tt>mainProfileNode:cal</tt> -> <tt>mainProfileNode:call_tree</tt><br>
    (only tried if there is a : in the word)
  </li>
  <li>Table/"Namespace" Completion:<br>
    <tt>math.e</tt> -> <tt>math.exp</tt>
  </li>
  <li>Completion of Lua globals, internal functions and modules (like \em math, 
    \em io, \em string), classes and global functions from the 
    <em>ug4-registry</em>, and functions defined in Lua script.
  </li>
</ul>


<hr>
\section secRuntimeInformation Runtime Information

You can get Information about the current state of Lua by the following methods:
<ul>
  <li>\code
void TypeInfo(const char *typename)
    \endcode
    \c TypeInfo prints all information available for the data you insert.
    Note that you have to enclose your type name with <tt>"</tt>.
    Example: <tt>TypeInfo("Grid")</tt>.
    \c TypeInfo works with
    <ul>
      <li>tables, and prints their content recursively</li>
      <li>all other basic lua types: numbers, strings, ...</li>
      <li>lua script functions, and prints their code</li>
      <li>classes, global functions and member function from the ug4-registry</li>
    </ul>
    The use of \c TypeInfo can be abbreviated by using
    \verbatim
ug:> Grid?
    \endverbatim
    and hitting enter.
    When the name left to the cursor is unambiguous, hitting tab three times 
    also displays information about the object. 
    Functions show their parameters when you enter the function and the first 
    bracket
    \verbatim
ug:> GetProfileNode(
    \endverbatim
    and hit tab.
  </li>
  <li>\code
void ClassUsage(const char *typename)
    \endcode
    \c ClassUsage prints the usage of the class, that is:
    <ul>
      <li>Functions returning an instantiation of the class</li>
      <li>Functions which require one argument to be of the type of the class 
        or of a base class
      </li>
      <li>Instatiations in Lua which have the type class or a subclass of the 
        class.
      </li>
    </ul>

    Example (excerpt):
    \verbatim
ug:> ClassUsage("Domain2d")

--- Functions returning Domain2d: ---
 Domain2d* IApproximationSpace2d:domain()
--- Functions using Domain2d: ---
 bool Domain2d:LoadDomain (Domain2d* Domain, string Filename, integer Number Refinements)
 bool Domain2d:DistributeDomain (Domain2d* )
 IRefiner* Domain2d:GlobalDomainRefiner (Domain2d* )
 Domain2d:TestDomainInterfaces (Domain2d* )
 IApproximationSpace2d:assign_domain ([Domain2d* ])
 DirichletBND2d:set_domain ([Domain2d* ])

Instantiations of Class Domain2d:
dom        (Domain2d)
    \endverbatim
  </li>
  <li>\code
void ls()
    \endcode	
    \c ls prints all available objects and classes in Lua, including 
    <ul>
      <li>global Lua objects, like normal Lua objects and instatiations of \ug4 
        classes
      </li>
      <li>Lua script functions</li>
      <li>global functions and classes from ug4-registry</li>
    </ul>
  </li>
</ul>


<hr>
\section secDebugging Debug Shell

You can also debug your Lua Script using the shell.
For this, you can use the script functions
<ul>
  <li>\verbatim
breakpoint()
    \endverbatim
    <tt>breakpoint()</tt> breaks the execution of the script at exactly the 
    location it stands.
    This is the preferred method of setting a breakpoint.
  </li>
  <li>\verbatim
breakpoint(source, line)
    \endverbatim
    <tt>breakpoint("laplace.lua", 69)</tt> adds a breakpoint at the file 
    <tt>"laplace.lua"</tt> (path relative to current script).
    <tt>print_breakpoints</tt> prints those.
    Note that only lines with code are "catched" by the compiler.
  </li>
</ul>

When your breakpoint is reached, you are entering the \ug4 <em>debug shell</em>:
\verbatim
./../scripts/laplace.lua:69 breakpoint()
debug:> 
\endverbatim

The debug shell is like the normal ugshell (so it has \ref secAutoCompletion 
and \ref secRuntimeInformation), but you have some extra commands.
Most of them have a similar function as in \em gdb:
- <tt>continue, cont</tt> &mdash; Continues execution.
- <tt>step</tt> &mdash; Continues execution until the next line is reached, 
  steps into subroutines.
- <tt>next</tt> &mdash; Continues execution until the next line is reached, 
  does not step into subroutines (that is, we are skipping lines with greater 
  function stack depth).
- <tt>finish</tt> &mdash; Finishes subroutines/scripts (continues execution 
  until a line is reached with lower function stack depth).
- <tt>list</tt> &mdash; Lists the script surrounding the current statement.
- <tt>backtrace, bt</tt> &mdash; Prints the function stack.
- <tt>up, down</tt> &mdash; Goes up and down the function stack.
- <tt>quit, exit</tt> &mdash; Like in normal shell, exits ug4 directly.
- <tt>print VAL</tt> &mdash; Like <tt>VAL?</tt>

Note that you don't have to configure \ug4 with <tt>cmake -DDEBUG=ON ..</tt>) 
to use the debug shell. 
There is a small performance drawback when using 
<tt>breakpoint(source, line)</tt> because we have to check for every line if it 
is a break line. 
This is especially the case if you have lots of small calls in your Lua script.
However, there is no performance drawback in <tt>breakpoint()</tt>.


<hr>
\section secBashCompletion Bash Completion for ugshell

If you want to use bash completion for ugshell in non-interactive mode, two 
feasible variants are suggested:
First (a simple) variant:
\verbatim
complete -o plusdirs -G "*+(lua|ugx)" -W "-ex -grid -numRefs -numPreRefs" ugshell
\endverbatim

This will enable to use <tt>ugshell \<TAB\> \<TAB\></tt> which will complete 
the key words (behind \c -W), all directories and only those files which match 
the extended glob (behind \c -G).

\note Please note that you need to set the <tt>extglob</tt> shell option to 
<tt>on</tt> in order to use extended globbings like:
<tt>*+(lua|ugx)</tt>.
Put the following line into your <tt>.bashrc</tt> respectively into your 
<tt>.bash_profile</tt> dependent on your local settings in your <tt>$HOME</tt>:
\verbatim
shopt extglob on 
\endverbatim

As the first simple variant sometimes does not work as expected and is too 
little extensible too, a second variant is suggested, which uses a function 
(bash function).
You need to supply that function to the \c -F parameter of the complete command.
Put the following two functions into your <tt>.bashrc</tt> respectively 
<tt>.bash_profile</tt> dependent on your local settings in your <tt>$HOME</tt>:
\verbatim
my_complete() {
  local word="$1"
  local ext=$2
  local i=0 line
  declare -a liste

  while read line; do liste[i++]="$line"; done < <(compgen -f -- "$word")

  local w
  for w in "${liste[@]}"; do 
    [[ -d "$w" ]] && continue
    [[ "${w##*.}" = $ext ]] && COMPREPLY[i++]="$w" 
  done
}
\endverbatim

\verbatim
my_complete_ugshell () {
   my_complete "$2" "*+(lua|ugx|obj)"
}
\endverbatim

\note Now, to enable the completion, proceed as before.
Please note the additional part at the end of the line.
\verbatim 
complete -W "-ex -grid -numRefs -numPreRefs" -o plusdirs -F my_complete_ugshell ugshell
\endverbatim

Finally, navigating on a terminal may seem uncomfortable, definining a (bash) 
shell function <em>cdug</em> could improve that:
\verbatim
function cdug() {
   local UG4_ROOT=~/ug4
   local SEP=_
   local DEST=
   local CD_CMD=cd
  
   if [ -z "$1" ]; then
      DEST=$UG4_ROOT/trunk
   else
      case $1 in
      builds)
         DEST=$UG4_ROOT/builds
         ;;
      trunk)
         DEST=$UG4_ROOT/trunk
         ;;
      branches)
         DEST=$UG4_ROOT/branches/;
         ;;
      plugins)
         DEST=$UG4_ROOT/trunk/plugins/;
         ;;
      plugins/ex*)
         DEST=$UG4_ROOT/trunk/plugins/experimental/;
         ;;
      plugins/co*)
         DEST=$UG4_ROOT/trunk/plugins/core/;
         ;;
      build$SEP*)
         DEST=$UG4_ROOT/builds/${1##*$SEP}/;
         ;;
      branch$SEP*)
         DEST=$UG4_ROOT/branches/${1##*$SEP}/;
         ;;
      docs)
         DEST=$UG4_ROOT/trunk/docs/;
         ;;
      apps)
         DEST=$UG4_ROOT/trunk/apps;
         ;;
      scripts)
         DEST=$UG4_ROOT/trunk/scripts;
         ;;
      unit_tests)
         DEST=$UG4_ROOT/trunk/unit_tests;
         ;;
      data)
         DEST=$UG4_ROOT/trunk/data;
         ;;
      ugbase)
         DEST=$UG4_ROOT/trunk/ugbase;
         ;;
      bin)
         DEST=$UG4_ROOT/trunk/bin;
         ;;
      externals)
         DEST=$UG4_ROOT/trunk/externals;
         ;;
      lib)
         DEST=$UG4_ROOT/trunk/lib;
         ;;
      tags)
         DEST=$UG4_ROOT/tags
         ;;
      tag$SEP)
         DEST=$UG4_ROOT/tags/${1##*$SEP}/;
         ;;
      *)
         DEST=$UG4_ROOT/$1
         ;;
      esac
   fi
   
   if [ ! -d "$DEST" ]; then
      echo -e  "\e[0;35m$1\e[0;30m: directory does not exist, changing to \e[0;35m$UG4_ROOT\e[0;30m (UG4_ROOT) instead."
      $CD_CMD $UG4_ROOT
   else
      $CD_CMD $DEST
   fi

}
\endverbatim
\note Enable completion:
\verbatim
complete -W "apps bin builds branches data docs externals lib scripts tags trunk ugbase unit_tests plugins" cdug # -o pl
\endverbatim

*/

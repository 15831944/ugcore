//	created by Martin Rupp
//	martin.rupp@gcsc.uni-frankfurt.de
//	y11 m04 d13

/**	\page pageUG4Shell ugshell

	- \ref secCommandLineOption "Command-Line Options"
	- \ref secInteractiveShell "Interactive Shell"
	- \ref secAutoCompletion "Auto Completion"
	- \ref secRuntimeInformation "Runtime Information"
	- \ref secDebugging "Debug Shell"
	- \ref secBashCompletion "Bash Completion for ugshell"

For any questions, contact martin.rupp@gcsc.uni-frankfurt.de.

<hr>
\section secCommandLineOption Command-Line Options
<hr>

ugshell has the following build-in command-line options:
	- -outproc id:	Sets the output-proc to id. Default is 0.
	- -ex scriptname:	Executes the specified script.
	- -noquit: Does run the interactive shell after specified script.
	- -noterm: Terminal logging will be disabled.
	- -logtofile filename:	Output will be written to the specified file.

You can also use the command line to pass arguments to your scripts:
\verbatim
./ugshell -ex tutorials/tut02_loading_a_domain.lua -grid unit_square/unit_square_quads_2x2.ugx  
\endverbatim

You can access command line parameters by using the lua function from ug_util.lua:
\code
function util.GetParam(name, return_if_unavailable)
\endcode

For that, you have to include the ug_util.lua file using ug_load_script("ug_util.lua").

Example:
\code
ug_load_script("ug_util.lua")
gridName = util.GetParam("-grid", "unit_square/unit_square_quads_8x8.ugx")
\endcode

If there is no commandline argument "-grid", then the second argument is returned by util.GetParam.
Otherwise, the argument after "-grid" in the commandline is returned.
Notice that omitted parameters to lua-functions are treated as nil, so util.GetParam("-grid") is
the same as util.GetParam("-grid", nil). If you want your argument to be casted
to a number, use util.GetParamNumber:
\code
function util.GetParamNumber(name, return_if_unavailable)
\endcode
If the argument is not a number, the second argument is returned. 
To check if an option is in the command line, use util.HasParamOption:
\code
function util.HasParamOption(name)
\endcode
Examples:
\code
dim = util.GetParamNumber("-dim", 2)
useAggressiveCoarsening = util.HasParamOption("-AC")
\endcode



<hr>
\section secInteractiveShell Interactive Shell
<hr>

When starting ugshell without arguments, you get the following output:

\verbatim
ug:> 
\endverbatim

and a blinking cursor: This is called the interactive shell. Interactive shell is disabled
when you use -ex without -noquit and if UG is running in parallel.

In the interactive shell you can start the LUA script <tt>&lt;scriptname&gt;</tt> (as usual) by executing
<tt>ug_load_script()</tt>:
\verbatim
ug:> ug_load_script(<scriptname>)
\endverbatim
where <tt>&lt;scriptname&gt;</tt> is currently searched
<ol>
<li> relative to the currently loaded script</li>
<li> absolute,</li>
<li> relative to <tt>PathProvider::get_path(SCRIPT_PATH)</tt> (i.e <tt>\<ugshelldir\>/../scripts</tt>).
</ol>

(Using <tt>ug_load_script()</tt> is the preferred method of loading scripts; alternatively a script can be loaded using the (standard LUA) function <tt>dofile()</tt>.)

You can abort the execution of UG out of lua scripts by using <tt>exit()</tt>.
If you want to stop the execution of a script at a specific place, but you want to use the interactive shell thereafter, 
insert at that place a call like <tt>error("break")</tt> (or whatever message sounds reasonable to you) and start the run with the <tt>-noquit</tt>. option

Please note that the interactive shell currently is not available in a parallel environment.

<hr>
\section secAutoCompletion Auto Completion
<hr>

ugshell has some auto-completion features implemented. When you enter a part of something and hit tab
ugshell tries to auto-complete your input. If there is not a unique completion, 
and you hit tab again, you get a list of possible completions.
 
<ul>
<li> 
Path Completion: <br>
"../scr -> "../scripts/ <br>
(only tried if the word left from the cursor starts with a ")
<li> 
Member Function Completion: <br>
mainProfileNode:cal -> mainProfileNode:call_tree <br>
(only tried if there is a : in the word)
<li>
Table/"Namespace" Completion:<br>
math.e -> math.exp
<li>
Completion of LUA globals, internal functions and modules (like math, io, string),
classes and global functions from the ug registry, and functions defined in lua script. 
</ul>

<hr>
\section secRuntimeInformation Runtime Information
<hr>

You can get Information about the current state of LUA by the following methods:
<ul>
<li> 
\code
void TypeInfo(const char *typename)
\endcode
TypeInfo prints all information available for the data you insert. Note that you have to enclose your
type name with ". Example: TypeInfo("Grid"). TypeInfo works with
<ul>
<li> tables, and prints their content recursively
<li> all other basic lua types: numbers, strings, ...
<li> lua script functions, and prints their code
<li> classes, global functions and member function from the ug registry
</ul>
The use of TypeInfo can be abbreviated by using
\verbatim
ug:> Grid?
\endverbatim
and hitting enter. When the name left to the cursor is unambiguous, hitting tab three times also displays information about the object. 
Functions show their parameters when you enter the function and the first bracket
\verbatim
ug:> GetProfileNode(
\endverbatim
and hit tab.

<li>
\code
void ClassUsage(const char *typename)
\endcode
ClassUsage prints the usage of the class, that is:
<ul>
<li> Functions returning an instantiation of the class 
<li> Functions which require one argument to be of the type of the class or of a base class
<li> Instatiations in LUA which have the type class or a subclass of the class.
</ul>

Example (excerpt):
\verbatim
ug:> ClassUsage("Domain2d")

--- Functions returning Domain2d: ---
 Domain2d* IApproximationSpace2d:domain()
--- Functions using Domain2d: ---
 bool Domain2d:LoadDomain (Domain2d* Domain, string Filename, integer Number Refinements)
 bool Domain2d:DistributeDomain (Domain2d* )
 IRefiner* Domain2d:GlobalDomainRefiner (Domain2d* )
 Domain2d:TestDomainInterfaces (Domain2d* )
 IApproximationSpace2d:assign_domain ([Domain2d* ])
 DirichletBND2d:set_domain ([Domain2d* ])

Instantiations of Class Domain2d:
dom        (Domain2d)
\endverbatim

<li>
\code
void ls()
\endcode	
ls prints all available objects and classes in LUA, including 
<ul>
<li> global LUA objects, like normal LUA objects and instatiations of UG classes
<li> LUA script functions
<li> global functions and classes from UG registry
</ul>

</ul>


<hr>
\section secDebugging Debug Shell
<hr>

You can also debug your LUA Script using the shell. For this, you can use the script functions
<ul>
<li>
\verbatim
breakpoint()
\endverbatim
breakpoint() breaks the execution of the script at exactly the location it stands. This is the preferred method of setting a breakpoint.
<li>
\verbatim
breakpoint(source, line)
\endverbatim
breakpoint("laplace.lua", 69) adds a breakpoint at the file "laplace.lua" (path relative to current script). print_breakpoints prints those. Note that only lines with code are "catched" by the compiler.
</ul>

When your breakpoint is reached, you are entering the ug4 debug shell:
\verbatim
./../scripts/laplace.lua:69 breakpoint()
debug:> 
\endverbatim

The debug shell is like the normal ug4 shell (so it has \ref secAutoCompletion and \ref secRuntimeInformation), but you have some extra commands. Most of them have a similar function as in gdb:

<ul>
<li> <tt>continue, cont</tt> : Continues execution.
<li> <tt>step</tt> : Continues execution until the next line is reached, steps into subroutines.
<li> <tt>next</tt> : Continues execution until the next line is reached, does not step into subroutines (that is, we are skipping lines with greater function stack depth).
<li> <tt>finish</tt> : Finishes subroutines/scripts (continues execution until a line is reached with lower function stack depth).
<li> <tt>list</tt> : Lists the script surrounding the current statement.
<li> <tt>backtrace, bt</tt> : Prints the function stack.
<li> <tt>up, down</tt> : Goes up and down the function stack.
<li> <tt>quit, exit</tt> : Like in normal shell, exits ug4 directly.
<li> <tt>print VAL</tt> : Like <tt>VAL?</tt>
</ul>

Note that you don't have to configure ug4 with <tt>cmake -DDEBUG=ON ..</tt>) to use the debug shell. 
There is a small performance drawback when using <tt>breakpoint(source, line)</tt> because we have to check for every line if it is a break line. 
This is especially the case if you have lots of small calls in your lua script. However, there is no performance drawback in <tt>breakpoint()</tt>.


<hr>
\section secBashCompletion Bash Completion for ugshell
<hr>
You can also use bash completion for ugshell in non-interactive mode.
First (simple) variant:
\verbatim
complete -o plusdirs -G "*+(lua|ugx)" -W "-ex -grid -numRefs -numPreRefs" ugshell
\endverbatim
Please note that you need to set the <tt>extglob</tt> shell option to "on" in order to use extended globbings like: "*+(lua|ugx)". Put the following line into your <tt>.bashrc</tt> respectively into your <tt>.bash_profile</tt> in your <tt>$HOME</tt>:
\verbatim
shopt extglob on 
\endverbatim
As for me the first variant did not work as expected (listing of lua, ugx files and directories, cf. for yourself ;-) please) and isn't very extensible too, a second variant is presented where you can supply a function to the -F parameter of the complete command.
Put the following two function into your <tt>.bashrc</tt> resp. <tt>.bash_profile</tt> (or you may create a file <tt>.my_complete.bash</tt> and source it):
\verbatim
my_complete() {
   local word="$1"
   local ext=$2
   local i=0 line
   declare -a liste

   while read line; do liste[i++]="$line"; done < <(compgen -f -- "$word")

   local w
   for w in "${liste[@]}"; do 
      [[ -d "$w" ]] && continue
      [[ "${w##*.}" = $ext ]] && COMPREPLY[i++]="$w" 
   done
}
\endverbatim
\verbatim
my_complete_ugshell () {
   my_complete "$2" "*+(lua|ugx|obj)"
}
\endverbatim
Now you can turn on completion as before:
\verbatim 
complete -W "-ex -grid -numRefs -numPreRefs" -o plusdirs -F my_complete_ugshell ugshell
\endverbatim
Please contact stephan.grein@gcsc.uni-frankfurt.de for any questions.

*/
/*
  created
  Martin Rupp <martin.rupp@gcsc.uni-frankfurt.de>
  y11 m04 d13

  refactored
  Torbj√∂rn Klatt <torbjoern@torbjoern-klatt.de>
  y12 m03 d30
*/

/** \page pageUG4Shell ugshell

- \ref secCommandLineOption "Command-Line Options"
- \ref secInteractiveShell "Interactive Shell"
- \ref secAutoCompletion "Auto Completion"
- \ref secRuntimeInformation "Runtime Information"
- \ref secDebugging "Debug Shell"
- \ref secBashCompletion


<hr>
\section secCommandLineOption Command Line Options

ugshell has the following build-in command-line options:
- <tt>-outproc id</tt> &mdash; Sets the output-proc to id. Default is 0.
- <tt>-ex scriptname</tt> &mdash; Executes the specified script.
- <tt>-noquit</tt> &mdash; Does run the interactive shell after specified 
  script.
- <tt>-noterm</tt> &mdash; Terminal logging will be disabled.
- <tt>-logtofile filename</tt> &mdash; Output will be written to the specified 
  file.

You can also use the command line to pass arguments to your scripts:
\verbatim
./ugshell -ex tutorials/tut02_loading_a_domain.lua -grid unit_square/unit_square_quads_2x2.ugx  
\endverbatim

You can access command line parameters by using the Lua function from 
<tt>ug_util.lua</tt>:
\code
function util.GetParam(name, return_if_unavailable)
\endcode

For that, you have to include the <tt>ug_util.lua</tt> file using 
<tt>ug_load_script("ug_util.lua")</tt>.

Example:
\code
ug_load_script("ug_util.lua")
gridName = util.GetParam("-grid", "unit_square/unit_square_quads_8x8.ugx")
\endcode

If there is no commandline argument <tt>-grid</tt>, then the second argument 
is returned by <tt>util.GetParam</tt>.
Otherwise, the argument after <tt>-grid</tt> in the commandline is returned.
Notice that omitted parameters to Lua functions are treated as <tt>nil</tt>, 
so <tt>util.GetParam("-grid")</tt> is the same as 
<tt>util.GetParam("-grid", nil)</tt>.
If you want your argument to be casted to a number, use 
<tt>util.GetParamNumber</tt>:
\code
function util.GetParamNumber(name, return_if_unavailable)
\endcode

If the argument is not a number, the second argument is returned. 
To check if an option is in the command line, use <tt>util.HasParamOption</tt>:
\code
function util.HasParamOption(name)
\endcode

Examples:
\code
dim = util.GetParamNumber("-dim", 2)
useAggressiveCoarsening = util.HasParamOption("-AC")
\endcode


<hr>
\section secInteractiveShell Interactive Shell

When starting ugshell without arguments, you get the following output:
\verbatim
ug:> 
\endverbatim

and a blinking cursor:
This is called the <em>interactive shell</em>.
Interactive shell is disabled when you use <tt>-ex</tt> without 
<tt>-noquit</tt> and if UG4 is running in parallel.

In the interactive shell you can start the Lua script 
<tt>&lt;scriptname&gt;</tt> (as usual) by executing <tt>ug_load_script()</tt>:
\verbatim
ug:> ug_load_script(<scriptname>)
\endverbatim

where <tt>&lt;scriptname&gt;</tt> is currently searched
<ol>
  <li>relative to the currently loaded script</li>
  <li>absolute,</li>
  <li>relative to <tt>PathProvider::get_path(SCRIPT_PATH)</tt> (i.e 
    <tt>&lt;ugshelldir&gt;/../scripts</tt>).
  </li>
</ol>

(Using <tt>ug_load_script()</tt> is the preferred method of loading scripts; 
alternatively a script can be loaded using the (standard Lua) function 
<tt>dofile()</tt>.)

You can abort the execution of UG4 out of Lua scripts by using <tt>exit()</tt>.
If you want to stop the execution of a script at a specific place, but you want 
to use the interactive shell thereafter, insert at that place a call like 
<tt>error("break")</tt> (or whatever message sounds reasonable to you) and 
start the run with the <tt>-noquit</tt> option.

Please note that the interactive shell currently is not available in a parallel 
environment.


<hr>
\section secAutoCompletion Auto Completion

<em>ugshell</em> has some auto-completion features implemented.
When you enter a part of something and hit tab <em>ugshell</em> tries to 
auto-complete your input.
If there is not a unique completion, and you hit tab again, you get a list of 
possible completions.
 
<ul>
  <li>Path Completion:<br>
    <tt>../scr</tt> -> <tt>../scripts/</tt><br>
    (only tried if the word left from the cursor starts with a '<tt>"</tt>')
  </li>
  <li>Member Function Completion:<br>
    <tt>mainProfileNode:cal</tt> -> <tt>mainProfileNode:call_tree</tt><br>
    (only tried if there is a '<tt>:</tt>' in the word)
  </li>
  <li>Table/"Namespace" Completion:<br>
    <tt>math.e</tt> -> <tt>math.exp</tt>
  </li>
  <li>Completion of Lua globals, internal functions and modules (like 
    <tt>math</tt>, <tt>io</tt>, <tt>string</tt>), classes and global functions 
    from the <em>ug-Registry</em>, and functions defined in Lua script.
  </li>
</ul>


<hr>
\section secRuntimeInformation Runtime Information

You can get Information about the current state of Lua by the following methods:
<ul>
  <li>\code
    void TypeInfo(const char *typename)
    \endcode
    <tt>TypeInfo</tt> prints all information available for the data you insert.
    Note that you have to enclose your type name with '<tt>"</tt>'.
    Example: <tt>TypeInfo("Grid")</tt>.
    <tt>TypeInfo</tt> works with
    <ul>
      <li>tables, and prints their content recursively</li>
      <li>all other basic Lua types: <tt>numbers</tt>, <tt>strings</tt>, ...</li>
      <li>Lua script functions, and prints their code</li>
      <li>classes, global functions and member function from the ug-Registry</li>
    </ul>
    The use of <tt>TypeInfo</tt> can be abbreviated by using
    \verbatim
    ug:> Grid?
    \endverbatim
    and hitting enter.
    When the name left to the cursor is unambiguous, hitting tab three times 
    also displays information about the object. 
    Functions show their parameters when you enter the function and the first 
    bracket
    \verbatim
    ug:> GetProfileNode(
    \endverbatim
    and hit tab.
  </li>
  <li>\code
    void ClassUsage(const char *typename)
    \endcode
    <tt>ClassUsage</tt> prints the usage of the class, that is:
    <ul>
      <li>Functions returning an instantiation of the class</li>
      <li>Functions which require one argument to be of the type of the class 
        or of a base class
      </li>
      <li>Instatiations in Lua which have the type class or a subclass of the 
        class.
      </li>
    </ul>

    Example (excerpt):
    \verbatim
    ug:> ClassUsage("Domain2d")

    --- Functions returning Domain2d: ---
    Domain2d* IApproximationSpace2d:domain()
    --- Functions using Domain2d: ---
    bool Domain2d:LoadDomain (Domain2d* Domain, string Filename, integer Number Refinements)
    bool Domain2d:DistributeDomain (Domain2d* )
    IRefiner* Domain2d:GlobalDomainRefiner (Domain2d* )
    Domain2d:TestDomainInterfaces (Domain2d* )
    IApproximationSpace2d:assign_domain ([Domain2d* ])
    DirichletBND2d:set_domain ([Domain2d* ])

    Instantiations of Class Domain2d:
    dom        (Domain2d)
    \endverbatim
  </li>
  <li>\code
    void ls()
    \endcode
    <tt>ls</tt> prints all available objects and classes in Lua, including 
    <ul>
      <li>global Lua objects, like normal Lua objects and instatiations of UG4 
        classes
      </li>
      <li>Lua script functions</li>
      <li>global functions and classes from ug-Registry</li>
    </ul>
  </li>
</ul>


<hr>
\section secDebugging Debug Shell

You can also debug your Lua script using the shell.
For this, you can use the script functions
<ul>
  <li>
    \verbatim
    breakpoint()
    \endverbatim
    <tt>breakpoint()</tt> breaks the execution of the script at exactly the 
    location it stands.
    This is the preferred method of setting a breakpoint.
  </li>
  <li>
    \verbatim
    breakpoint(source, line)
    \endverbatim
    <tt>breakpoint("laplace.lua", 69)</tt> adds a breakpoint at the file 
    <tt>"laplace.lua"</tt> (path relative to current script).
    <tt>print_breakpoints</tt> prints those.
    Note that only lines with code are "catched" by the compiler.
  </li>
</ul>

When your breakpoint is reached, you are entering the UG4 <em>debug shell</em>:
\verbatim
./../scripts/laplace.lua:69 breakpoint()
debug:> 
\endverbatim

The debug shell is like the normal UG4 shell (so it has \ref secAutoCompletion 
and \ref secRuntimeInformation), but you have some extra commands.
Most of them have a similar function as in <em>gdb</em>:

- <tt>continue, cont</tt> &mdash; Continues execution.
- <tt>step</tt> &mdash; Continues execution until the next line is reached, 
  steps into subroutines.
- <tt>next</tt> &mdash; Continues execution until the next line is reached, 
  does not step into subroutines (that is, we are skipping lines with greater 
  function stack depth).
- <tt>finish</tt> &mdash; Finishes subroutines/scripts (continues execution 
  until a line is reached with lower function stack depth).
- <tt>list</tt> &mdash; Lists the script surrounding the current statement.
- <tt>backtrace, bt</tt> &mdash; Prints the function stack.
- <tt>up, down</tt> &mdash; Goes up and down the function stack.
- <tt>quit, exit</tt> &mdash; Like in normal shell, exits ug4 directly.
- <tt>print VAL</tt> &mdash; Like <tt>VAL?</tt>

\note Note that you don't have to configure UG4 with <tt>cmake -DDEBUG=ON ..</tt>) 
to use the debug shell.

There is a small performance drawback when using 
<tt>breakpoint(source, line)</tt> because we have to check for every line if it 
is a break line. 
This is especially the case if you have lots of small calls in your Lua script.
However, there is no performance drawback in <tt>breakpoint()</tt>.


<hr>
\section secBashCompletion Bash Completion for ugshell

If you want to use bash completion for ugshell in non-interactive mode, two 
feasible variants are suggested:
First (a simple) variant:
\verbatim
complete -o plusdirs -G "*+(lua|ugx)" -W "-ex -grid -numRefs -numPreRefs" ugshell
\endverbatim

This will enable to use <em>ugshell <TAB> <TAB></em> which will complete the key
words (behind -W), all directories and only those files which match the extended
glob (behind -G).

Please note that you need to set the <tt>extglob</tt> shell option to 
<tt>on</tt> in order to use extended globbings like:
<tt>*+(lua|ugx)</tt>.
Put the following line into your <tt>.bashrc</tt> respectively into your 
<tt>.bash_profile</tt> dependent on your local settings in your <tt>$HOME</tt>:
\verbatim
shopt extglob on 
\endverbatim

As the first simple variant sometimes does not work as expected and is too little
extensible too, a second variant is suggested, which uses a function (bash function).
You need to supply that function to the <tt>-F</tt> parameter of the complete command.
Put the following two functions into your <tt>.bashrc</tt> respectively 
<tt>.bash_profile</tt> dependent on your local settings in your <tt>$HOME</tt>:
\verbatim
my_complete() {
  local word="$1"
  local ext=$2
  local i=0 line
  declare -a liste

  while read line; do liste[i++]="$line"; done < <(compgen -f -- "$word")

  local w
  for w in "${liste[@]}"; do 
    [[ -d "$w" ]] && continue
    [[ "${w##*.}" = $ext ]] && COMPREPLY[i++]="$w" 
  done
}
\endverbatim

\verbatim
my_complete_ugshell () {
   my_complete "$2" "*+(lua|ugx|obj)"
}
\endverbatim

Now, to enable the completion, proceed as before. Please note the additional part
at the end of the line.
\verbatim 
complete -W "-ex -grid -numRefs -numPreRefs" -o plusdirs -F my_complete_ugshell ugshell
\endverbatim

Finally, navigating on a terminal may seem uncomfortable, definining a (bash) 
shell function <em>cdug</em> could improve that:
\verbatimfunction cdug() {
   local UG4_ROOT=~/ug4
   local SEP=_
   
   if [ ! -d "$UG4_ROOT/$1" -o -z "$1" ]; then
      echo -e  "\e[0;35m$1\e[0;30m: directory does not exist, changing to \e[0;35m$UG4_ROOT\e[0;30m (UG4_ROOT) instead."
      cd $UG4_ROOT;
   else
      if [[ "$1" == builds ]]; then 
         cd $MY_UG4_ROOT/builds;
      elif [[ "$1" == trunk ]]; then
         cd $MY_UG4_ROOT/trunk/;
      elif [[ "$1" == branches ]]; then
         cd $UG4_ROOT/branches/;
      elif [[ "$1" == plugins* ]]; then
         if [[ "$1" == plugins/ex* ]]; then
            cd $UG4_ROOT/trunk/plugins/experimental/;
         elif [[ "$1" == plugins/co* ]]; then
            cd $UG4_ROOT/trunk/plugins/core/;
         else
            cd $UG4_ROOT/trunk/plugins/;
         fi
      elif [[ "$1" == build_* ]]; then
         cd $UG4_ROOT/builds/${1#$SEP}/;
      elif [[ "$1" == branch_* ]]; then
         cd $UG4_ROOT/branches/${1#$SEP}/;
      elif [[ "$1" == docs ]]; then
         cd $UG4_ROOT/trunk/docs/;
      elif [[ "$1" == apps ]]; then
         cd $UG4_ROOT/trunk/apps;
      elif [[ "$1" == scripts ]]; then
         cd $UG4_ROOT/trunk/scripts;
      elif [[ "$1" == unit_tests ]]; then
         cd $UG4_ROOT/trunk/unit_tests;
      elif [[ "$1" == data ]]; then
         cd $UG4_ROOT/trunk/data;
      elif [[ "$1" == ugbase ]]; then
         cd $UG4_ROOT/trunk/ugbase;
      else
         cd $UG4_ROOT;
      fi
   fi
}
complete -W "apps builds branches data docs scripts trunk ugbase unit_tests plugins" # -o plusdirs cdug
Optionally you can supply -o plusdirs for <TAB> complete directories.
*/

################################################################################
# created by Sebastian Reiter, Andreas Vogel, Martin Rupp, Michael Hoffer, ...
# s.b.reiter@googlemail.com
#
# This file handles all options, with which ug can be compiled. Depending on
# those options, it then resolves all dependencies by adding required
# include-paths and by linking to required libraries.
# It also sets associated defines which can be queried in C and C++ Code.
#
# If you're creating an executable or a library which mainly depends on ug4,
# including this file in your CMakeLists.txt may be a good idea.
################################################################################

################################################################################
# Make sure code is only executed once.
# (no indent here, since it affects the whole file)
if(NOT UG_CMAKE_INCLUDES_INCLUDED)
set(UG_CMAKE_INCLUDES_INCLUDED on)


################################################################################
# include ug header and library path
get_filename_component(UG_ROOT_PATH ${CMAKE_CURRENT_LIST_FILE} PATH)
include_directories(${UG_ROOT_PATH}/ugbase)
include_directories(${CMAKE_BINARY_DIR})
link_directories(${UG_ROOT_PATH}/lib)


################################################################################
# We want the code to be built into one library (except the plugins, of course)
set(BUILD_ONE_LIB ON)


# Those variables control the build process. They are later modified depending
# on the value of TARGET.
set(buildUGShell OFF)
set(buildForVRL OFF)
set(buildAlgebra OFF)
set(buildPluginSystem OFF)
set(buildCorePlugins OFF)
set(buildSharedLib OFF)
set(buildGrid OFF)
set(buildDisc OFF)
set(buildBridge OFF)
set(buildBindings OFF)
set(buildRegistry OFF)

# Here we'll store libs, if we find and need them
set(linkLibraries)

################################################################################
# In this section we'll define default variables
	
# Values for the TARGET option
set(targetOptions "ugshell, vrl, libug4, libgrid, ugplugin, gridshell, amg")
set(targetDefault "ugshell")
set(targetExecutableName ugshell)
set(targetLibraryName ug4)

# Values for the DIM option
set(dimOptions "1, 2, 3, ALL, \"1\;2\", \"1\;3\", \"2\;3"\")
set(dimDefault "ALL")

# Values for the CPU option
set(cpuOptions "1, 2, 3, 4, VAR, ALL, \"2\;4\", \"1\;3\;4\" , ..." )
set(cpuDefault "ALL")

# Values for the blas / lapack option
set(blasDefault ON)
set(lapackDefault ON)

# If enabled, the boost version contained in the externals folder will be used
set(internalBoostDefault ON)

# Option to add svn head revision, compile date and build host into ugshell's initial output
set(svnDefault OFF)

# Precision of the number type
set(precisionDefault "double")
set(precisionOptions "single, double")

# If we run the script the first time, search for MPI to determine the default valuei
if(BUILTIN_MPI)
  set(MPI_FOUND YES)
else(BUILTIN_MPI)
 if(NOT mpiHasBeenSearched)
	find_package(MPI)
	set(mpiHasBeenSearched ON CACHE BOOL "This var is set to true after mpi has been searched the first time.")
  endif(NOT mpiHasBeenSearched)
endif(BUILTIN_MPI)


################################################################################
# All available options should be defined here:
# cmake-options can either be on or off.
# note: none-on/off-variables are set below, and the docstring is set at the end of this file


# the following options are real cmake-options
option(STATIC "Enables static linking. Valid options are: ON, OFF" OFF)
option(DEBUG "Enables debugging. Valid options are: ON, OFF" OFF)
option(DEBUG_LOGS "Enables debug output. Valid options are: ON, OFF" OFF)
option(PARALLEL "Enables parallel compilation. Valid options are: ON, OFF" ${MPI_FOUND})
option(PROFILER "Enables the internal profiler. Valid options are: ON, OFF" OFF)
option(PROFILE_PCL "Enables profiling of the pcl-library. Valid options are ON, OFF" OFF)
option(PCL_DEBUG_BARRIER "Enables debug barriers in the pcl-library. Valid options are ON, OFF" OFF)
option(LAPACK "Lapack won't be used, even if available. Valid options are ON, OFF" ${lapackDefault})
option(BLAS "Blas won't be used, even if available. Valid options are ON, OFF" ${blasDefault})
option(INTERNAL_BOOST "If enabled, the boost version found in the externals directory will be used. Valid options are ON, OFF" ${internalBoostDefault})
option(BUILTIN_BLAS "BLAS is built into compiler" OFF)
option(BUILTIN_LAPACK "LAPACK is built into compiler" OFF)
option(BUILTIN_MPI "MPI is built into compiler" OFF)
option(EMBED_SVN_REV "Enables output of SVN head revision, compile date and build host. Valid options are ON, OFF" ${svnDefault})

################################################################################
# set default values for pseudo-options
if(NOT TARGET)
	if(BUILDING_PLUGIN)
		set(TARGET ugplugin)
	else(BUILDING_PLUGIN)
		set(TARGET ${targetDefault})
	endif(BUILDING_PLUGIN)
endif(NOT TARGET)

if(NOT DIM)
	set(DIM ${dimDefault})
endif(NOT DIM)

if(NOT CPU)
	set(CPU ${cpuDefault})
endif(NOT CPU)

if(NOT PRECISION)
	set(PRECISION ${precisionDefault})
endif(NOT PRECISION)

# convert the DIM and CPU sets to readable sets
# otherwise "2;3" gets "23" .
# todo: make this a function/macro
set(DIMReadable "")
foreach(d ${DIM})
	if("${DIMReadable}" STREQUAL "")
		set(DIMReadable ${d})
	else("${DIMReadable}" STREQUAL "")
		set(DIMReadable "${DIMReadable}" "\;" ${d})
	endif("${DIMReadable}" STREQUAL "")
endforeach(d)
set(CPUReadable "")
foreach(d ${CPU})
	if("${CPUReadable}" STREQUAL "")
		set(CPUReadable ${d})
	else("${CPUReadable}" STREQUAL "")
		set(CPUReadable "${CPUReadable}" "\;" ${d})
	endif("${CPUReadable}" STREQUAL "")
endforeach(d)

################################################################################
# We'll output the current options-setting in this section
message(STATUS "")
message(STATUS "Info: Current options:")
message(STATUS "Info: TARGET:            "${TARGET}" (options are: "${targetOptions}")")
message(STATUS "Info: DIM:               "${DIMReadable}" (options are: "${dimOptions}")")
message(STATUS "Info: CPU:               "${CPUReadable}" (options are: "${cpuOptions}")")
message(STATUS "Info: PRECISION:         "${PRECISION}" (options are: "${precisionOptions}")")
message(STATUS "Info: STATIC:            "${STATIC}" (options are: ON, OFF)")
message(STATUS "Info: DEBUG:             "${DEBUG}" (options are: ON, OFF)")
message(STATUS "Info: DEBUG_LOGS:        "${DEBUG_LOGS}" (options are: ON, OFF)")
message(STATUS "Info: PARALLEL:          "${PARALLEL}" (options are: ON, OFF)")
message(STATUS "Info: PCL_DEBUG_BARRIER: "${PCL_DEBUG_BARRIER}" (options are: ON, OFF)")
message(STATUS "Info: PROFILER:          "${PROFILER}" (options are: ON, OFF)")
message(STATUS "Info: PROFILE_PCL:       "${PROFILE_PCL}" (options are: ON, OFF)")
message(STATUS "Info: LAPACK:            "${LAPACK}" (options are: ON, OFF)")
message(STATUS "Info: BLAS:              "${BLAS}" (options are: ON, OFF)")
message(STATUS "Info: INTERNAL_BOOST:    "${INTERNAL_BOOST}" (options are: ON, OFF)")
message(STATUS "Info: EMBED_SVN_REV:     "${EMBED_SVN_REV}" (options are: ON, OFF)")
message(STATUS "")
message(STATUS "Info: External libraries (set them to the path, which contains the library):")
message(STATUS "Info: METIS:    "${METIS})
message(STATUS "Info: PARMETIS: "${PARMETIS})
message(STATUS "Info: TETGEN:   "${TETGEN})
message(STATUS "Info: HYPRE:    "${HYPRE})
message(STATUS "Info: HLIBPRO:  "${HLIBPRO})
message(STATUS "")
message(STATUS "Info: C Compiler ID: ${CMAKE_C_COMPILER_ID}, C++ Compiler ID: ${CMAKE_CXX_COMPILER_ID}") 
message(STATUS "")

################################################################################
# Options are processed in this section.

########################################
# TARGET
add_definitions(-DUG_TARGET="${TARGET}") # (dummy) preprocessor directive used for displaying build configuration

# The target option enables specific build variables
if("${TARGET}" STREQUAL "ugshell")
	set(buildUGShell ON)
	set(buildAlgebra ON)
	set(buildPluginSystem ON)
	set(buildCorePlugins ON)	# will be disabled later on if STATIC is enabled
	set(buildGrid ON)
	set(buildDisc ON)
	set(buildBridge ON)
	set(buildBindings ON)
	set(buildRegistry ON)
	
elseif("${TARGET}" STREQUAL "vrl")
	# The vrl works only, if a dynamic library is built.
	if(STATIC)
		message(FATAL_ERROR "ug4 for vrl can only be build as a dynamic library. Please set STATIC = OFF.")
	endif(STATIC)
	
	set(buildAlgebra ON)
	set(buildForVRL ON)
	set(buildPluginSystem ON)
	set(buildCorePlugins ON)	# will be disabled later on if STATIC is enabled
	#todo: rename targetLibraryName to ug4_vrl
	#set(targetLibraryName ug4_vrl)
	set(buildGrid ON)
	set(buildDisc ON)
	set(buildBridge ON)
	set(buildBindings ON)
	set(buildRegistry ON)
	
elseif("${TARGET}" STREQUAL "libug4")
	set(buildAlgebra ON)
	set(buildPluginSystem ON)
	set(buildCorePlugins ON)	# will be disabled later on if STATIC is enabled
	set(buildGrid ON)
	set(buildDisc ON)
	set(buildBridge ON)
	set(buildBindings ON)
	set(buildRegistry ON)
	
elseif("${TARGET}" STREQUAL "libgrid")
	set(targetLibraryName grid)
	set(buildGrid ON)

elseif("${TARGET}" STREQUAL "ugplugin")
	# Note that the STATIC option for plugins should not change the fact,
	# that a plugin is compiled as a dynamic library. However, the plugin
	# should try to link against the static ug4_s library.
	set(buildAlgebra ON)
	set(buildGrid ON)
	set(buildDisc ON)
	set(buildPluginSystem ON)
	set(buildBridge ON)
	set(buildBindings ON)
	set(buildRegistry ON)

elseif("${TARGET}" STREQUAL "gridshell")
	set(targetExecutableName gridshell)
	set(buildUGShell ON)
	set(buildPluginSystem ON)
	set(buildCorePlugins ON)	# will be disabled later on if STATIC is enabled
	set(buildGrid ON)
	set(buildDisc ON)
	set(buildBridge ON)
	set(buildBindings ON)
	set(buildRegistry ON)
	
elseif("${TARGET}" STREQUAL "amg")
	set(targetLibraryName ugamg)
	set(buildAlgebra ON)
	
else("${TARGET}" STREQUAL "ugshell")
	message(FATAL_ERROR "Unsupported TARGET: "${TARGET}". Options are: "${targetOptions})
	
endif("${TARGET}" STREQUAL "ugshell")

########################################
# PRECISION
if("${PRECISION}" STREQUAL "single")
	add_definitions(-DUG_SINGLE_PRECISION)
elseif("${PRECISION}" STREQUAL "double")
	# Nothing to do here. double-precision is the default
else("${PRECISION}" STREQUAL "single")
	message(FATAL_ERROR "Unsupported PRECISION: "${PRECISION}". Options are: "${precisionOptions})
endif("${PRECISION}" STREQUAL "single")

########################################
# STATIC
# If STATIC is enabled, then a static ug-lib will be built. This will add a
# _s suffix to the resulting lib name.
# Note that no plugins are built if STATIC is enabled.


if(STATIC)
	set(buildDynamicLib OFF)
	set(buildPluginSystem OFF)
	set(buildCorePlugins OFF)
	set(targetLibraryName ${targetLibraryName}_s)
	add_definitions(-DUG_STATIC) # dummy preprocessor macro used for printout build config
else(STATIC)
	set(buildDynamicLib ON)
	set(UG_SHARED ON)
endif(STATIC)


########################################
# DIM
# The dim option sets defines for C and C++
if("${DIM}" STREQUAL "ALL")
	add_definitions(-DUG_DIM_1 -DUG_DIM_2 -DUG_DIM_3)
	
else("${DIM}" STREQUAL "ALL")
	# DIM is a string of dimensions (e.g. "1;2")
	# loop dims
	foreach(d ${DIM})
		# check if dim is valid
		if(d GREATER 3 OR d LESS 1)
			message(FATAL_ERROR "ERROR: Cannot build world dimension ${d}. "
								"Valid options are: "${dimOptions})
		endif(d GREATER 3 OR d LESS 1)
	
		add_definitions(-DUG_DIM_${d})
	endforeach(d)
endif("${DIM}" STREQUAL "ALL")

########################################
# CPU
# The cpu option sets defines for C and C++
if("${CPU}" STREQUAL "ALL")
	# todo checks for 4, VAR (-DUG_CPU_4 -DUG_CPU_VAR)!
	add_definitions(-DUG_CPU_1 -DUG_CPU_2 -DUG_CPU_3)
	
else("${CPU}" STREQUAL "ALL")
	# CPU is a string of numbers (e.g. "1;2")
	# loop dims
	foreach(d ${CPU})
		# check if dim is valid
		if(d GREATER 4 OR d LESS 1)
			message(FATAL_ERROR "ERROR: Cannot build cpu blocksize ${d}. "
								"Valid options are: "${cpuOptions})
		endif(d GREATER 4 OR d LESS 1)
	
		add_definitions(-DUG_CPU_${d})
	endforeach(d)
endif("${CPU}" STREQUAL "ALL")

########################################
# DEBUG

if(NOT CRAY)
	add_definitions(-Wall)
else(NOT CRAY)
	# add support for gnu extensions
	add_definitions(-h gnu)
endif(NOT CRAY)


if(DEBUG)
	add_definitions(-g)
	add_definitions(-DUG_DEBUG)
	
	# This code would enable strict bounds checking for STL objects like in vector::operator[]. 
	# however, GLIBCXX_DEBUG and strstream don't work together on mac (bug: http://bit.ly/cH78bC). 
	# when this bug is fixed, one could set those flags (or similar) depending on the compiler.
	if("${CMAKE_CXX_COMPILER_ID}" STREQUAL "GNU" AND NOT APPLE)
		add_definitions(-D_GLIBCXX_DEBUG=1 -D_GLIBCXX_DEBUG_PEDANTIC=1)
	ENDIF("${CMAKE_CXX_COMPILER_ID}" STREQUAL "GNU" AND NOT APPLE)

else(DEBUG)
	add_definitions(-O3)
	if("${CMAKE_C_COMPILER_ID}" STREQUAL "GNU")
		add_definitions(-funroll-loops -ftree-vectorize)
	endif(NOT CRAY)
	add_definitions(-DNDEBUG -DBOOST_UBLAS_NDEBUG)
endif(DEBUG)

if(DEBUG_LOGS)
	add_definitions(-DUG_ENABLE_DEBUG_LOGS)
endif(DEBUG_LOGS)

########################################
# PROFILER
if(PROFILER)
	add_definitions(-DUG_PROFILER)
endif(PROFILER)


########################################
# PROFILE_PCL
if(PROFILE_PCL)
	add_definitions(-DPROFILE_PCL)
endif(PROFILE_PCL)


########################################
# PCL_DEBUG_BARRIER
if(PCL_DEBUG_BARRIER)
	add_definitions(-DPCL_DEBUG_BARRIER_ENABLED)
endif(PCL_DEBUG_BARRIER)


########################################
# buildAlgebra
if(buildAlgebra)
	add_definitions(-DUG_ALGEBRA)
	
	# we'll check for lapack and blas here
	if(LAPACK OR BLAS)
		# On OSX, we know where lapack and blas are located. To avoid errors
		# with Fortran compilers on OSX, we'll add APPLE as a special case here.
		if(APPLE)
			if(LAPACK)
				set(LAPACK_LIBRARIES "-framework vecLib" CACHE STRING "LAPACK library" FORCE)
				FIND_PATH(LAPACK_INCLUDE_PATH clapack.h /usr/local/include/ /usr/include /include)
				if(LAPACK_INCLUDE_PATH)
		  			set(LAPACK_FOUND YES)
		  		endif(LAPACK_INCLUDE_PATH)
			endif(LAPACK)
			
			if(BLAS)
				set(BLAS_LIBRARIES "-framework vecLib" CACHE STRING "CBLAS library" FORCE)
				find_path(BLAS_INCLUDE_PATH cblas.h /usr/local/include/ /usr/include /include)
				set(BLAS_FOUND YES)
				if(BLAS_INCLUDE_PATH)
					set(BLAS_FOUND YES)
				endif(BLAS_INCLUDE_PATH)
			endif(BLAS)
			
		elseif(CRAY)
			set(BUILTIN_BLAS YES)
			set(BUILTIN_LAPACK YES)			
		else(APPLE)
			# a fortran compiler is required to find the packages
			# Sadly there seems to be a cmake-bug, hence the following workaround.
			# ENABLE_LANGUAGE workaround begin (issue 0009220)
			message(STATUS "Info: If problems with the Fortran compiler occur, consider deactivating LAPACK and BLAS")
			if(DEFINED CMAKE_Fortran_COMPILER AND CMAKE_Fortran_COMPILER MATCHES "^$")
			  set(CMAKE_Fortran_COMPILER CMAKE_Fortran_COMPILER-NOTFOUND)
			endif(DEFINED CMAKE_Fortran_COMPILER AND CMAKE_Fortran_COMPILER MATCHES "^$")
			# ENABLE_LANGUAGE workaround end (issue 0009220)
			
			ENABLE_LANGUAGE(Fortran OPTIONAL)
			if(CMAKE_Fortran_COMPILER_WORKS)
				if(LAPACK)
					find_package(LAPACK)
				endif(LAPACK)
				
				if(BLAS)
					find_package(BLAS)
				endif(BLAS)
				
			endif(CMAKE_Fortran_COMPILER_WORKS)
		endif(APPLE)
		
	# We'll output whether lapack and blas are used, to avoid misconceptions
		if(LAPACK_FOUND)
			message(STATUS "Info: Using Lapack")
			include_directories (${LAPACK_INCLUDE_PATH})
			set(linkLibraries ${linkLibraries} ${LAPACK_LIBRARIES})
			add_definitions(-DLAPACK_AVAILABLE)
		elseif(BUILTIN_LAPACK)
			message(STATUS "Info: Using Builtin Lapack")
			add_definitions(-DLAPACK_AVAILABLE)
		else(LAPACK_FOUND)	
			message(STATUS "Info: Not using Lapack. No package found.")
		endif(LAPACK_FOUND)
		
		if(BLAS_FOUND)
			message(STATUS "Info: Using Blas")
			include_directories (${BLAS_INCLUDE_PATH})
			set(linkLibraries ${linkLibraries} ${BLAS_LIBRARIES})
			add_definitions(-DBLAS_AVAILABLE)
		elseif(BUILTIN_BLAS)
			message(STATUS "Info: Using Builtin Blas")
			add_definitions(-DBLAS_AVAILABLE)
		else(BLAS_FOUND)	
			message(STATUS "Info: Not using Blas. No package found.")
		endif(BLAS_FOUND)
		
	endif(LAPACK OR BLAS)
endif(buildAlgebra)


########################################
# METIS
if(METIS)
	find_library(METIS_LIBS NAMES metis PATHS ${METIS})
	if(METIS_LIBS-NOTFOUND)
		message(FATAL_ERROR "ERROR: Couldn't find METIS in the specified path.")
	else(METIS_LIBS-NOTFOUND)
		add_definitions(-DUG_METIS)
		include_directories(${METIS}/Lib)
		set(linkLibraries ${linkLibraries} ${METIS_LIBS})		
	endif(METIS_LIBS-NOTFOUND)
endif(METIS)

########################################
# PARMETIS
if(PARMETIS)
	find_library(PARMETIS_LIBS NAMES metis parmetis PATHS ${PARMETIS})
	if(PARMETIS_LIBS-NOTFOUND)
		message(FATAL_ERROR "ERROR: Couldn't find PARMETIS in the specified path.")
	else(PARMETIS_LIBS-NOTFOUND)
		add_definitions(-DUG_PARMETIS)
		include_directories(${PARMETIS})
		set(linkLibraries ${linkLibraries} ${PARMETIS_LIBS})		
	endif(PARMETIS_LIBS-NOTFOUND)
endif(PARMETIS)

########################################
# TETGEN
if(TETGEN)
	find_library(TETGEN_LIBS NAMES tet PATHS ${TETGEN})
	if(TETGEN_LIBS-NOTFOUND)
		message(FATAL_ERROR "ERROR: Couldn't find TETGEN in the specified path.")
	else(TETGEN_LIBS-NOTFOUND)
		add_definitions(-DUG_TETGEN -DTETLIBRARY)
		include_directories(${TETGEN})
		set(linkLibraries ${linkLibraries} ${TETGEN_LIBS})
	endif(TETGEN_LIBS-NOTFOUND)
endif(TETGEN)

########################################
# HYPRE
if(HYPRE)
	find_library(HYPRE_LIBS HYPRE PATHS ${HYPRE})

	if(HYPRE_LIBS-NOTFOUND)
		message(FATAL_ERROR "ERROR: Couldn't find HYPRE in the specified path.")
	else(HYPRE_LIBS-NOTFOUND)
		add_definitions(-DUG_HYPRE -DHYPRELIB_DIR) # TODO: Is '-DHYPRELIB_DIR' used?
		include_directories(${HYPRE}/../include/)
		set(linkLibraries ${linkLibraries} ${HYPRE_LIBS})
	endif(HYPRE_LIBS-NOTFOUND)
endif(HYPRE)

########################################
# HLIBPRO
if(HLIBPRO)
#	find_library(HLIBPRO_LIBS NAMES hpro PATHS ${HLIBPRO})
	find_library(HLIBPRO_LIBS NAMES libhpro.dylib PATH_SUFFIXES ../hlibpro-0.13.6/lib/ ${HLIBPRO}) # hlib built as shared lib via 'scons shared=1 static=0' (26092011ih)
	find_path (HLIBPROLIB_DIR libhpro.dylib
		PATHS ENV PATH
		PATH_SUFFIXES ../hlibpro-0.13.6/lib/ )
#	message(STATUS "INFO: Using HLibPro; content of 'HLIBPRO_LIBS' is '${HLIBPRO_LIBS}', content of 'HLIBPROLIB_DIR' is '${HLIBPROLIB_DIR}'.")
	if(HLIBPRO_LIBS-NOTFOUND)
		message(FATAL_ERROR "ERROR: Couldn't find HLIBPRO in the specified path.")
	else(HLIBPRO_LIBS-NOTFOUND)
#		add_definitions(-DHLIBPROLIB_DIR)
		add_definitions(-DUG_HLIBPRO)
		include_directories(${HLIBPROLIB_DIR}/../include/)
		include_directories(${HLIBPROLIB_DIR}/../src/include/)
		set(linkLibraries ${linkLibraries} ${HLIBPRO_LIBS})
	endif(HLIBPRO_LIBS-NOTFOUND)
endif(HLIBPRO)


################################################################################
# find and collect required libraries

########################################
# boost (required)
if(INTERNAL_BOOST)
	include_directories(${UG_ROOT_PATH}/externals/boost_1_48_0/)
	message(STATUS "Info: Using externals/boost_1_48_0")
else(INTERNAL_BOOST)
	find_package(Boost REQUIRED)
	include_directories(${Boost_INCLUDE_DIRS})

	if(Boost_FOUND)
		if(Boost_MAJOR_VERSION GREATER 1 OR Boost_MINOR_VERSION GREATER 39)
			#message(STATUS "Info: Using BOOST (version ${Boost_MAJOR_VERSION}.${Boost_MINOR_VERSION}.${Boost_SUBMINOR_VERSION}, libs at '${Boost_INCLUDE_DIRS}').")
			
		else(Boost_MAJOR_VERSION GREATER 1 OR Boost_MINOR_VERSION GREATER 39)
			# we require a newer version of boost
			message(FATAL_ERROR " BOOST in ${Boost_INCLUDE_DIRS} is not compatible (required 1.40.0, but is ${Boost_MAJOR_VERSION}.${Boost_MINOR_VERSION}.${Boost_SUBMINOR_VERSION}) . NO Boost available. Aborting.")	
		endif(Boost_MAJOR_VERSION GREATER 1 OR Boost_MINOR_VERSION GREATER 39)
	else(Boost_FOUND)
		message(FATAL_ERROR " BOOST not found! NO Boost available, but at least boost 1.40.0 is required. Aborting.")
	endif(Boost_FOUND)
	
endif(INTERNAL_BOOST)


########################################
# dynamic linking
if(UNIX)
    set(linkLibraries ${linkLibraries} dl)
elseif(WIN32)
	set(linkLibraries ${linkLibraries} Kernel32)
endif(UNIX)


########################################
# MPI
if(PARALLEL)
	if(BUILTIN_MPI)
		add_definitions(-DUG_PARALLEL)
	else(BUILTIN_MPI)
		# search mpi
		find_package(MPI)
		# MPI is required for parallel builds
		if(MPI_FOUND)
			add_definitions(-DUG_PARALLEL)
			include_directories(${MPI_INCLUDE_PATH})
			set(linkLibraries ${linkLibraries} ${MPI_LIBRARY} ${MPI_EXTRA_LIBRARY})
		else(MPI_FOUND)
			message(FATAL_ERROR "MPI not found. Please set PARALLEL to OFF (run cmake -DPARALLEL=OFF ...)")
		endif(MPI_FOUND)
	endif(BUILTIN_MPI)
endif(PARALLEL)

if(HERMIT_EXPERIMENTAL)
	add_definitions(-DUG_PARALLEL)
	add_definitions(-DBLAS_AVAILABLE)
	add_definitions(-DLAPACK_AVAILABLE)
	message(STATUS "Info: Using experimental stuff on Hermit.")
endif(HERMIT_EXPERIMENTAL)

########################################
# JNI
if(buildForVRL)
	find_package(JNI REQUIRED)
    include_directories(${JNI_INCLUDE_DIRS})
	add_definitions(-DFOR_VRL)
endif(buildForVRL)


################################################################################
# This is a hidden option, which is currently only required for builds on jugene.
# Note that the associated option is enabled in toolchain_file_jugene.cmake
if(enableDynamicOption)
	add_definitions(-dynamic)
endif(enableDynamicOption)

################################################################################
# make global svn revision, compile date and build host available as C++ macro
################################################################################
IF(EMBED_SVN_REV)
include(FindSubversion)

	IF(Subversion_FOUND)
		#MESSAGE(STATUS "Info: Embedding svn-revision number.")
	        EXECUTE_PROCESS(
	                COMMAND "svnversion" "--no-newline" ${CMAKE_SOURCE_DIR}
	                OUTPUT_VARIABLE svn_version
	                ERROR_VARIABLE svn_version
	        )
	
	        # write a file with the SVN_REVISION define
	        file(WRITE ${CMAKE_BINARY_DIR}/svnrevision.h "#define SVN_REVISION \"${svn_version}\"\n")
	
	ELSE(Subversion_FOUND)
		MESSAGE(STATUS "WARNING: Looking for Subversion - not found (disable EMBED_SVN_REV with -DEMBED_SVN_REV=OFF)")
	        # write a file with the SVN_REVISION define
	        file(WRITE ${CMAKE_BINARY_DIR}/svnrevision.h "#define SVN_REVISION \"unknown revision\"\n")
	ENDIF(Subversion_FOUND)
	
ELSE(EMBED_SVN_REV)
	#MESSAGE(STATUS "INFO: Not looking for Subversion - (Enable EMBED_SVN_REV with -DEMBED_SVN_REV=ON)")
        # write a file with the SVN_REVISION define
        file(WRITE ${CMAKE_BINARY_DIR}/svnrevision.h "#define SVN_REVISION \"unknown revision\"\n")
ENDIF(EMBED_SVN_REV)
####
# make compile date stamp available as C++ macro
####

IF(UNIX)
    execute_process(COMMAND date
        OUTPUT_VARIABLE compile_date OUTPUT_STRIP_TRAILING_WHITESPACE
    )
    # write a file with the COMPILE_DATE define
    file(WRITE ${CMAKE_BINARY_DIR}/compiledate.h "#define COMPILE_DATE \"${compile_date}\"\n")

    execute_process(COMMAND hostname
        OUTPUT_VARIABLE hostname OUTPUT_STRIP_TRAILING_WHITESPACE
    )
    # write a file with the BUILD_HOST define
    file(WRITE ${CMAKE_BINARY_DIR}/build_hostname.h "#define BUILD_HOST \"${hostname}\"\n")

ELSEIF(WIN32)
    #MESSAGE(STATUS "INFO: On Windows: time stamp generation unsupported!")
    # write a file with the COMPILE_DATE define
    file(WRITE ${CMAKE_BINARY_DIR}/compiledate.h "#define COMPILE_DATE \"unknown date\"\n")
    #MESSAGE(STATUS "INFO: On Windows: hostname generation unsupported!")
    # write a file with the BUILD_HOST define
    file(WRITE ${CMAKE_BINARY_DIR}/build_hostname.h "#define BUILD_HOST \"unknown\"\n")
ENDIF(UNIX)

################################################################################
# Those options are temporary and should be removed in future builds.
# They are left from the old build script.
if(buildPluginSystem)
	add_definitions(-DUG_PLUGINS)
endif(buildPluginSystem)
if(buildBridge)
	add_definitions(-DUG_BRIDGE)
endif(buildBridge)
set(UG_PROFILER ${PROFILER})
set(UG_DEBUG ${DEBUG})
set(USE_NEW_CMAKE_INCLUDES ON)


################################################################################
# link against required libraries
link_libraries(${linkLibraries})


################################################################################
# Finally declare a method that allows all sub-cmake-files to add their sources
# to a common library.

#######################
# Export sources to global variable.
# PURPOSE: use this function to add local package sources to global
#          ugSources property which is used to build libug4
# @param prefix current directory prefix
# @param sources sources list to export
function(ExportSources prefix sources)
    # iterate over all arguments and insert given prefix
    foreach(l ${ARGV})
        # FIXME: this is a hack to omit the first argument
        #        which is the prefix. Shall we use boolean or index variable?
        if(NOT "${l}" STREQUAL "${prefix}")
            # retrieve the global property ugSources and store it
            # in tmp variable
            # NOTE: properties must be assigned to variables before being used
            get_property(tmp GLOBAL PROPERTY ugSources)
            # append tmp to the global ugSources property using the correct prefix
            set_property(GLOBAL PROPERTY ugSources ${tmp} "${prefix}/${l}")
        endif(NOT "${l}" STREQUAL "${prefix}")
    endforeach(l)
endfunction(ExportSources)


######################################################################################################################
# the following options are pseudo cmake-options (normal options only support ON and OFF).
# Their default values are defined in the section above.
# we need to put this here so we only have to set the doc string and the type once.
# note: do not change the variables after this

set(TARGET ${TARGET} CACHE STRING "Set the target of this build process. Valid options are: ${targetOptions}")
set(DIM ${DIM} CACHE STRING "Set the dimension for which ug4 is build. Valid options are: ${dimOptions}")
set(CPU ${CPU} CACHE STRING "Set block sizes for which ug4 is build. Valid options are: ${cpuOptions}")
set(PRECISION ${PRECISION} CACHE STRING "Set the precision of the number type. Valid options are: ${precisionOptions}")

# the following options too are pseudo cmake-options. However, they should
# contains pathes, if set.
set(METIS ${METIS} CACHE PATH "Sets the path in which metis shall be searched.")
set(PARMETIS ${PARMETIS} CACHE PATH "Sets the path in which parmetis shall be searched.")
set(TETGEN ${TETGEN} CACHE PATH "Sets the path in which tetgen shall be searched.")
set(HYPRE ${HYPRE} CACHE PATH "Sets the path in which hypre shall be searched.")
set(HLIBPRO ${HLIBPRO} CACHE PATH "Sets the path in which hlibpro shall be searched.")


# mark some stuff as advanced, so it won't show up in ccmake / CMakeSetup.exe
mark_as_advanced(CMAKE_INSTALL_PREFIX)
IF(APPLE)
	mark_as_advanced(CMAKE_OSX_ARCHITECTURES)
	mark_as_advanced(CMAKE_OSX_DEPLOYMENT_TARGET)
	mark_as_advanced(CMAKE_OSX_SYSROOT)
ENDIF(APPLE)
mark_as_advanced(LAPACK_INCLUDE_PATH)
mark_as_advanced(LAPACK_LIBRARIES)
mark_as_advanced(libReadline)
mark_as_advanced(mpiHasBeenSearched)
mark_as_advanced(BLAS_INCLUDE_PATH)
mark_as_advanced(BLAS_LIBRARIES)
mark_as_advanced(CMAKE_BUILD_TYPE)

mark_as_advanced(BUILTIN_LAPACK)
mark_as_advanced(BUILTIN_BLAS)
mark_as_advanced(BUILTIN_MPI)

endif(NOT UG_CMAKE_INCLUDES_INCLUDED)
